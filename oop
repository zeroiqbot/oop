                             Proxy
// Step 1: Define the Subject interface.
public interface Subject {
    void doOperation();
}

// Step 2: Create the RealSubject class.
public class RealSubject implements Subject {
    public void doOperation() {
        // Actual implementation goes here.
        System.out.println("Doing operation in RealSubject");
    }
}

// Step 3: Create the Proxy class.
public class Proxy implements Subject {
    private RealSubject realSubject;

    public Proxy(RealSubject realSubject) {
        this.realSubject = realSubject;
    }

    public void doOperation() {
        // Code to execute before delegating to the real subject (Pre-processing).
        System.out.println("Proxy pre-processing operation");

        // Delegating the operation to the real subject.
        realSubject.doOperation();

        // Code to execute after delegating to the real subject (Post-processing).
        System.out.println("Proxy post-processing operation");
    }
}

// Step 4: Using the Proxy in a client.
public class Client {
    public static void main(String[] args) {
        RealSubject real = new RealSubject();
        Proxy proxy = new Proxy(real);
        proxy.doOperation();
    }
}







                                                         AbstractFactory
// Step 1: Define Abstract Products interfaces
public interface AbstractProductA {
    void useProductA();
}

public interface AbstractProductB {
    void useProductB();
}

// Step 2: Create Concrete Products that implement these interfaces
public class ProductA1 implements AbstractProductA {
    public void useProductA() {
        System.out.println("ProductA1 used.");
    }
}

public class ProductA2 implements AbstractProductA {
    public void useProductA() {
        System.out.println("ProductA2 used.");
    }
}

public class ProductB1 implements AbstractProductB {
    public void useProductB() {
        System.out.println("ProductB1 used.");
    }
}

public class ProductB2 implements AbstractProductB {
    public void useProductB() {
        System.out.println("ProductB2 used.");
    }
}

// Step 3: Define AbstractFactory interface
public interface AbstractFactory {
    AbstractProductA createProductA();
    AbstractProductB createProductB();
}

// Step 4: Create Concrete Factories that implement AbstractFactory
public class ConcreteFactory1 implements AbstractFactory {
    public AbstractProductA createProductA() {
        return new ProductA1();
    }

    public AbstractProductB createProductB() {
        return new ProductB1();
    }
}

public class ConcreteFactory2 implements AbstractFactory {
    public AbstractProductA createProductA() {
        return new ProductA2();
    }

    public AbstractProductB createProductB() {
        return new ProductB2();
    }
}

// Step 5: Use the Abstract Factory in a client
public class Client {
    private AbstractProductA productA;
    private AbstractProductB productB;

    public Client(AbstractFactory factory) {
        productA = factory.createProductA();
        productB = factory.createProductB();
    }

    public void useProducts() {
        productA.useProductA();
        productB.useProductB();
    }

    public static void main(String[] args) {
        AbstractFactory factory1 = new ConcreteFactory1();
        Client client1 = new Client(factory1);
        client1.useProducts();

        AbstractFactory factory2 = new ConcreteFactory2();
        Client client2 = new Client(factory2);
        client2.useProducts();
    }
}








                                                       Adapter
// Step 1: Define the Target interface.
public interface Target {
    void request();
}

// Step 2: Create an Adaptee class with a different interface.
public class Adaptee {
    public void specificRequest() {
        System.out.println("Specific request being called on Adaptee.");
    }
}

// Step 3: Create an Adapter class that matches the Target interface.
public class Adapter implements Target {
    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        // Translate the methods appropriately.
        adaptee.specificRequest();
    }
}

// Step 4: Using the Adapter in a Client.
public class Client {
    public void doSomething(Target target) {
        target.request();
    }

    public static void main(String[] args) {
        Adaptee adaptee = new Adaptee();
        Target adapter = new Adapter(adaptee);
        Client client = new Client();
        client.doSomething(adapter);
    }
}






                                                   Bridge
// Step 1: Create the Implementor interface.
public interface Implementor {
    void newOperation();
}

// Step 2: Create concrete implementations that implement the Implementor interface.
public class ConcreteImplementor1 implements Implementor {
    public void newOperation() {
        System.out.println("ConcreteImplementor1 newOperation.");
    }
}

public class ConcreteImplementor2 implements Implementor {
    public void newOperation() {
        System.out.println("ConcreteImplementor2 newOperation.");
    }
}

// Step 3: Create the Abstraction interface.
public interface Abstraction {
    void doOperation();
}

// Step 4: Create a refined abstraction that extends the Abstraction interface.
public class AbstractionImp implements Abstraction {
    private Implementor implementor;

    public AbstractionImp(Implementor implementor) {
        this.implementor = implementor;
    }

    public void doOperation() {
        implementor.newOperation();
    }
}

// Step 5: Use the Abstraction in a client.
public class Client {
    public static void main(String[] args) {
        Implementor implementorA = new ConcreteImplementor1();
        Abstraction abstractionA = new AbstractionImp(implementorA);
        abstractionA.doOperation();

        Implementor implementorB = new ConcreteImplementor2();
        Abstraction abstractionB = new AbstractionImp(implementorB);
        abstractionB.doOperation();
    }
}









                                                      Builder
// Step 1: Create the Product class that is the complex object to be built.
public class Product {
    // You can add more parts to the product as needed.
    private String part;

    public void addPart(String part) {
        this.part = part;
    }

    public String getPart() {
        return part;
    }

    @Override
    public String toString() {
        return "Product with part: " + part;
    }
}

// Step 2: Define the Builder abstract interface.
public interface Builder {
    void buildPart();
    Product getResult();
}

// Step 3: Create a ConcreteBuilder to implement the Builder interface.
public class ConcreteBuilder implements Builder {
    private Product product = new Product();

    public void buildPart() {
        // Build parts of the product. This could be a complex operation.
        product.addPart("New Part");
    }

    public Product getResult() {
        return product;
    }
}

// Step 4: Define the Director class.
public class Director {
    public void construct(Builder builder) {
        builder.buildPart();
        // You could have more steps to build additional parts here.
    }
}

// Step 5: Use the Builder pattern in a client.
public class Client {
    public static void main(String[] args) {
        Director director = new Director();
        Builder builder = new ConcreteBuilder();
        director.construct(builder);

        Product product = builder.getResult();
        System.out.println(product);
    }
}












                                                    Chain
// Step 1: Define the Handler interface.
public abstract class Handler {
    protected Handler successor;

    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }

    public abstract void handleRequest(Request request);
}

// Step 2: Define a Request class (optional based on whether you need a specific request type).
public class Request {
    // Request-specific data, which handlers will use to determine what to do.
    private String type;

    public Request(String type) {
        this.type = type;
    }

    public String getType() {
        return type;
    }
}

// Step 3: Create ConcreteHandlers to handle the request or pass it on.
public class ConcreteHandler1 extends Handler {
    public void handleRequest(Request request) {
        if (request.getType().equals("Type1")) {
            System.out.println("ConcreteHandler1 handled request of Type1");
        } else if (successor != null) {
            successor.handleRequest(request);
        }
    }
}

public class ConcreteHandler2 extends Handler {
    public void handleRequest(Request request) {
        if (request.getType().equals("Type2")) {
            System.out.println("ConcreteHandler2 handled request of Type2");
        } else if (successor != null) {
            successor.handleRequest(request);
        }
    }
}

// Step 4: Use the pattern in a client.
public class Client {
    public static void main(String[] args) {
        // Setup Chain of Responsibility
        Handler h1 = new ConcreteHandler1();
        Handler h2 = new ConcreteHandler2();
        h1.setSuccessor(h2);

        // Send requests to the chain
        h1.handleRequest(new Request("Type1"));
        h1.handleRequest(new Request("Type2"));
        h1.handleRequest(new Request("Type3")); // This will not be handled
    }
}











                                            Command
// Step 1: Define the Command interface.
public interface Command {
    void execute();
}

// Step 2: Create one or more ConcreteCommand classes that implement the Command interface.
public class ConcreteCommand implements Command {
    private Receiver receiver;
    // State for the command, if needed
    private int state;

    public ConcreteCommand(Receiver receiver, int state) {
        this.receiver = receiver;
        this.state = state;
    }

    @Override
    public void execute() {
        receiver.action(); // Delegate the work to the receiver
    }
}

// Step 3: Define the Receiver class that will perform the actual action.
public class Receiver {
    public void action() {
        System.out.println("Action is being executed by the Receiver.");
    }
}

// Step 4: Define the Invoker class that will send the command.
public class Invoker {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void executeCommand() {
        command.execute();
    }
}

// Step 5: Use the pattern in a client.
public class Client {
    public static void main(String[] args) {
        Receiver receiver = new Receiver();
        Command command = new ConcreteCommand(receiver, 10); // state can be passed if required
        Invoker invoker = new Invoker();

        invoker.setCommand(command);
        invoker.executeCommand();
    }
}









                                                Composite
> Ilya Dereziuk:
// Step 1: Create the Component interface with an operation.
public interface Component {
    void doOperation();
}

// Step 2: Create a Leaf class that represents objects in the composition.
public class Leaf implements Component {
    public void doOperation() {
        System.out.println("Leaf operation performed.");
    }
}

// Step 3: Create a Composite class that stores child components.
public class Composite implements Component {
    private List<Component> children = new ArrayList<>();

    public void addComponent(Component component) {
        children.add(component);
    }

    public void removeComponent(Component component) {
        children.remove(component);
    }

    public Component getChild(int index) {
        return children.get(index);
    }

    public void doOperation() {
        System.out.println("Composite operation for all children:");
        for (Component child : children) {
            child.doOperation();
        }
    }
}

// Step 4: Use the Composite pattern in a client.
public class Client {
    public static void main(String[] args) {
        // Create leaf objects
        Leaf leaf1 = new Leaf();
        Leaf leaf2 = new Leaf();

        // Create composite objects
        Composite composite = new Composite();

        // Add leaf objects to the composite
        composite.addComponent(leaf1);
        composite.addComponent(leaf2);

        // Perform operation
        composite.doOperation();
    }
}







                                                    Decorator
// Step 1: Define the Component interface.
public interface Component {
    void doOperation();
}

// Step 2: Create a ConcreteComponent class that implements the Component interface.
public class ConcreteComponent implements Component {
    public void doOperation() {
        System.out.println("ConcreteComponent operation performed.");
    }
}

// Step 3: Create an abstract Decorator class implementing the Component interface.
public abstract class Decorator implements Component {
    protected Component decoratedComponent;

    public Decorator(Component decoratedComponent) {
        this.decoratedComponent = decoratedComponent;
    }

    public void doOperation() {
        decoratedComponent.doOperation();
    }
}

// Step 4: Create Concrete Decorators that extend the functionality of the component.
public class ConcreteDecoratorExtendingFunctionality extends Decorator {
    public ConcreteDecoratorExtendingFunctionality(Component decoratedComponent) {
        super(decoratedComponent);
    }

    public void doOperation() {
        super.doOperation();
        doAdditionalOperation();
    }

    public void doAdditionalOperation() {
        System.out.println("Additional operation by ConcreteDecoratorExtendingFunctionality.");
    }
}

public class ConcreteDecoratorExtendingState extends Decorator {
    private String additionalState = "Default State";

    public ConcreteDecoratorExtendingState(Component decoratedComponent) {
        super(decoratedComponent);
    }

    public void doOperation() {
        decoratedComponent.doOperation();
        System.out.println("State: " + additionalState);
    }

    public void setAdditionalState(String state) {
        this.additionalState = state;
    }
}

// Step 5: Use the Decorator pattern in a client.
public class Client {
    public static void main(String[] args) {
        Component concreteComponent = new ConcreteComponent();
        Component decoratorFunctionality = new ConcreteDecoratorExtendingFunctionality(concreteComponent);
        Component decoratorState = new ConcreteDecoratorExtendingState(concreteComponent);

        // Perform operation with additional functionality
        decoratorFunctionality.doOperation();

        // Perform operation with additional state
        ((ConcreteDecoratorExtendingState)decoratorState).setAdditionalState("New State");
        decoratorState.doOperation();
    }
}











                                                    FactoryMethod
// Step 1: Define the Product interface.
public interface Product {
    void doSomething();
}

// Step 2: Create a ConcreteProduct class that implements the Product interface.
public class ConcreteProduct implements Product {
    public void doSomething() {
        System.out.println("ConcreteProduct is doing something.");
    }
}

// Step 3: Define the Factory interface with the factory method.
public abstract class Factory {
    abstract Product factoryMethod();

    public void doSomething() {
        Product product = factoryMethod();
        product.doSomething();
        // Do something with the product
    }
}

// Step 4: Create a ConcreteFactory class that implements the factory method to return a new instance of a ConcreteProduct.
public class ConcreteFactory extends Factory {
    @Override
    Product factoryMethod() {
        return new ConcreteProduct();
    }
}

// Step 5: Use the Factory Method in a client.
public class Client {
    public static void main(String[] args) {
        Factory factory = new ConcreteFactory();
        factory.doSomething();
        // The ConcreteProduct is created and its doSomething method is called.
    }
}









                                                        FlyweightFactory
import java.util.HashMap;
import java.util.Map;

// Step 1: Define the Flyweight interface.
public interface Flyweight {
    void doOperation(String extrinsicState);
}

// Step 2: Create a ConcreteFlyweight class that implements the Flyweight interface.
public class ConcreteFlyweight implements Flyweight {
    private String intrinsicState;

    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    public void doOperation(String extrinsicState) {
        System.out.println("Intrinsic State = " + intrinsicState + ", Extrinsic State = " + extrinsicState);
    }
}

// Step 3: Create a FlyweightFactory class that returns an existing Flyweight or creates a new one if it doesn't exist.
public class FlyweightFactory {
    private Map<String, Flyweight> flyweights = new HashMap<>();

    public Flyweight getFlyweight(String key) {
        if (!flyweights.containsKey(key)) {
            flyweights.put(key, new ConcreteFlyweight(key));
        }
        return flyweights.get(key);
    }
}

// Step 4: Use the Flyweight pattern in a client.
public class Client {
    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();

        Flyweight flyweight1 = factory.getFlyweight("State1");
        Flyweight flyweight2 = factory.getFlyweight("State1");

        // In this case, flyweight1 and flyweight2 will be the same instance.

        flyweight1.doOperation("Extrinsic1");
        flyweight2.doOperation("Extrinsic2");
    }
}








                                                Interpreter
// Step 1: Define the Context class which contains information that will be interpreted.
class Context {
    // The state of the context, which may be used by the expressions during interpretation
}

// Step 2: Create an AbstractExpression interface with an interpret method.
interface AbstractExpression {
    void interpret(Context context);
}

// Step 3: Create a TerminalExpression class that implements the AbstractExpression interface.
class TerminalExpression implements AbstractExpression {
    public void interpret(Context context) {
        System.out.println("TerminalExpression interpreted with context.");
        // Interpretation based on the terminal expression and context state
    }
}

// Step 4: Create a NonTerminalExpression class that also implements the AbstractExpression interface.
class NonTerminalExpression implements AbstractExpression {
    public void interpret(Context context) {
        System.out.println("NonTerminalExpression interpreted with context.");
        // Interpretation based on the non-terminal expression and context state
    }
}

// Step 5: Use the Interpreter pattern in a client.
public class Client {
    public static void main(String[] args) {
        Context context = new Context();

        AbstractExpression terminal = new TerminalExpression();
        AbstractExpression nonTerminal = new NonTerminalExpression();

        terminal.interpret(context);
        nonTerminal.interpret(context);
        // Interpretations will be executed according to the logic defined in the expressions
    }
}

















                                                       Iterator
// Step 1: Define the Aggregate interface.
interface Aggregate {
    Iterator createIterator();
}

// Step 2: Define the Iterator interface.
interface Iterator {
    Object first();
    Object next();
    boolean isDone();
    Object currentItem();
}

// Step 3: Create a ConcreteAggregate class that implements the Aggregate interface.
class ConcreteAggregate implements Aggregate {
    private Object[] items;

    // Constructor
    public ConcreteAggregate(Object[] items) {
        this.items = items;
    }

    public Iterator createIterator() {
        return new ConcreteIterator(this);
    }

    // Other methods
    public int size() {
        return items.length;
    }

    public Object get(int index) {
        return items[index];
    }
}

// Step 4: Create a ConcreteIterator class that implements the Iterator interface.
class ConcreteIterator implements Iterator {
    private ConcreteAggregate aggregate;
    private int current = 0;

    public ConcreteIterator(ConcreteAggregate aggregate) {
        this.aggregate = aggregate;
    }

    public Object first() {
        return aggregate.get(0);
    }

    public Object next() {
        Object ret = null;
        if (current < aggregate.size() - 1) {
            ret = aggregate.get(++current);
        }
        return ret;
    }

    public boolean isDone() {
        return current >= aggregate.size();
    }

    public Object currentItem() {
        return aggregate.get(current);
    }
}

// Step 5: Use the Iterator pattern in a client.
public class Client {
    public static void main(String[] args) {
        Object[] items = {"Item1", "Item2", "Item3"};
        ConcreteAggregate aggregate = new ConcreteAggregate(items);
        Iterator iterator = aggregate.createIterator();

        for (Object item = iterator.first(); !iterator.isDone(); item = iterator.next()) {
            System.out.println((String) item);
        }
    }
}











                                                    Mediator
// Step 1: Define the Mediator interface.
interface Mediator {
    void send(String message, Colleague colleague);
}

// Step 2: Define the Colleague abstract class.
abstract class Colleague {
    protected Mediator mediator;

    public Colleague(Mediator mediator) {
        this.mediator = mediator;
    }

    public abstract void send(String message);
    public abstract void receive(String message);
}

// Step 3: Create a ConcreteMediator class that implements the Mediator interface.
class ConcreteMediator implements Mediator {
    private ConcreteColleague1 colleague1;
    private ConcreteColleague2 colleague2;

    public void setColleague1(ConcreteColleague1 colleague) {
        this.colleague1 = colleague;
    }

    public void setColleague2(ConcreteColleague2 colleague) {
        this.colleague2 = colleague;
    }

    public void send(String message, Colleague colleague) {
        if (colleague == colleague1) {
            colleague2.receive(message);
        } else if (colleague == colleague2) {
            colleague1.receive(message);
        }
    }
}

// Step 4: Create ConcreteColleague classes that extend the Colleague class.
class ConcreteColleague1 extends Colleague {
    public ConcreteColleague1(Mediator mediator) {
        super(mediator);
    }

    public void send(String message) {
        mediator.send(message, this);
    }

    public void receive(String message) {
        System.out.println("Colleague1 received message: " + message);
    }
}

class ConcreteColleague2 extends Colleague {
    public ConcreteColleague2(Mediator mediator) {
        super(mediator);
    }

    public void send(String message) {
        mediator.send(message, this);
    }

    public void receive(String message) {
        System.out.println("Colleague2 received message: " + message);
    }
}

// Step 5: Use the Mediator pattern in a client.
public class Client {
    public static void main(String[] args) {
        ConcreteMediator mediator = new ConcreteMediator();

        ConcreteColleague1 colleague1 = new ConcreteColleague1(mediator);
        ConcreteColleague2 colleague2 = new ConcreteColleague2(mediator);

        mediator.setColleague1(colleague1);
        mediator.setColleague2(colleague2);

        colleague1.send("Hello, Colleague2!");
        colleague2.send("Hello, Colleague1!");
    }
}












                                                    NullObject
// Step 1: Define the abstract class or interface.
abstract class AbstractOperation {
    public abstract void request();
}

// Step 2: Create a RealOperation class that implements the abstract operation.
class RealOperation extends AbstractOperation {
    @Override
    public void request() {
        System.out.println("RealOperation does something.");
    }
}

// Step 3: Create a NullOperation class that implements the abstract operation as a no-op.
class NullOperation extends AbstractOperation {
    @Override
    public void request() {
        // Do nothing
    }
}

// Step 4: Use the pattern in a client.
public class Client {
    private AbstractOperation operation; // This could be set via a setter or constructor

    public Client(AbstractOperation operation) {
        this.operation = operation;
    }

    public void makeRequest() {
        operation.request();
    }

    // Factory method to create an AbstractOperation. It could return a NullOperation or RealOperation
    public static AbstractOperation createOperation(boolean real) {
        if (real) {
            return new RealOperation();
        } else {
            return new NullOperation();
        }
    }

    public static void main(String[] args) {
        AbstractOperation operation = createOperation(true); // or false to get a NullOperation
        Client client = new Client(operation);
        client.makeRequest();
    }
}















                                                ObjectPool
import java.util.HashSet;
import java.util.Set;

// Step 1: Define the Reusable resource class.
class Reusable {
    // Add fields and methods for the Reusable objects here
    public void doSomething() {
        System.out.println("Doing something with the reusable object.");
    }
}

// Step 2: Create the ReusablePool class.
class ReusablePool {
    private static ReusablePool instance;
    private Set<Reusable> available = new HashSet<>();
    private Set<Reusable> inUse = new HashSet<>();

    private ReusablePool() {
        // Private constructor for singleton
    }

    public static synchronized ReusablePool getInstance() {
        if (instance == null) {
            instance = new ReusablePool();
        }
        return instance;
    }

    public synchronized Reusable acquireReusable() {
        if (available.isEmpty()) {
            Reusable newReusable = new Reusable();
            inUse.add(newReusable);
            return newReusable;
        } else {
            Reusable reusable = available.iterator().next();
            inUse.add(reusable);
            available.remove(reusable);
            return reusable;
        }
    }

    public synchronized void releaseReusable(Reusable reusable) {
        inUse.remove(reusable);
        available.add(reusable);
    }
}

// Step 3: Use the Object Pool in a client.
public class Client {
    public static void main(String[] args) {
        ReusablePool pool = ReusablePool.getInstance();

        // Acquire Reusable objects from the pool and use them
        Reusable reusable1 = pool.acquireReusable();
        reusable1.doSomething();

        // ... more operations

        // Release the Reusable object back to the pool
        pool.releaseReusable(reusable1);
    }
}











                                            Observer
import java.util.ArrayList;
import java.util.List;

// The state type used in Observable and Observers
class State {
    // Example state data
    private String data;

    public State(String data) {
        this.data = data;
    }

    // Accessors and other methods here
    public String getData() {
        return data;
    }
}

// Step 1: Define the Observer interface.
interface Observer {
    void update();
}

// Step 2: Define the Observable class.
class Observable {
    private List<Observer> observers = new ArrayList<>();
    private State state;

    public State getState() {
        return state;
    }

    public void setState(State state) {
        this.state = state;
        notifyObservers();
    }

    public void attach(Observer observer) {
        observers.add(observer);
    }

    public void detach(Observer observer) {
        observers.remove(observer);
    }

    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}

// Step 3: Create concrete Observable class.
class ConcreteObservable extends Observable {
    // ConcreteObservable may override other methods or add new ones
}

// Step 4: Create concrete Observer classes.
class ConcreteObserverA implements Observer {
    private State observerState;
    private ConcreteObservable observable;

    public ConcreteObserverA(ConcreteObservable observable) {
        this.observable = observable;
        this.observable.attach(this);
    }

    @Override
    public void update() {
        this.observerState = observable.getState();
        // Do something with the state
        System.out.println("Observer A State Updated: " + observerState.getData());
    }
}

class ConcreteObserverB implements Observer {
    private State observerState;
    private ConcreteObservable observable;

    public ConcreteObserverB(ConcreteObservable observable) {
        this.observable = observable;
        this.observable.attach(this);
    }

    @Override
    public void update() {
        this.observerState = observable.getState();
        // Do something with the state
        System.out.println("Observer B State Updated: " + observerState.getData());
    }
}

// Step 5: Use the pattern in a client.
public class Client {
    public static void main(String[] args) {
        ConcreteObservable observable = new ConcreteObservable();
        new ConcreteObserverA(observable);
        new ConcreteObserverB(observable);

        // Change the state and notify the observers
        observable.setState(new State("New State"));
        // The observers are now notified and updated
    }
}










                                        Prototype
public interface Prototype extends Cloneable {
    Prototype clone() throws CloneNotSupportedException;
}

public class ConcretePrototype1 implements Prototype {
    // Fields and methods

    @Override
    public ConcretePrototype1 clone() throws CloneNotSupportedException {
        // Here, the super.clone() method is used to perform shallow copying.
        return (ConcretePrototype1) super.clone();
    }
}

public class ConcretePrototype2 implements Prototype {
    // Fields and methods

    @Override
    public ConcretePrototype2 clone() throws CloneNotSupportedException {
        return (ConcretePrototype2) super.clone();
    }
}

public class Client {
    public static void main(String[] args) {
        try {
            ConcretePrototype1 obj1 = new ConcretePrototype1();
            // Clone obj1 into obj2
            ConcretePrototype1 obj2 = obj1.clone();

            // Operation that uses the cloned object
            // operation(obj2);
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}

















                                                        Singleton
public class Singleton {
    // The private static variable holds the single instance of the class
    private static Singleton instance;

    // The constructor is private to prevent instantiation from outside the class
    private Singleton() {
        // Initialization code here
    }

    // Public method to provide the global point of access
    public static Singleton getInstance() {
        // Lazy initialization: create the instance if it doesn't exist
        if (instance == null) {
            instance = new Singleton();
        }
        // Return the existing instance
        return instance;
    }

    // Other methods of the class can be defined here
}













                                                        Strategy
// Step 1: Create the strategy interface.
public interface IStrategy {
    void behaviorInterface();
}

// Step 2: Create concrete strategy classes.
public class ConcreteStrategyA implements IStrategy {
    public void behaviorInterface() {
        System.out.println("Behavior for strategy A");
    }
}

public class ConcreteStrategyB implements IStrategy {
    public void behaviorInterface() {
        System.out.println("Behavior for strategy B");
    }
}

public class ConcreteStrategyC implements IStrategy {
    public void behaviorInterface() {
        System.out.println("Behavior for strategy C");
    }
}

// Step 3: Create the context class.
public class Context {
    private IStrategy strategy;

    public Context(IStrategy strategy) {
        this.strategy = strategy;
    }

    public void someMethod() {
        // The context delegates some work to the strategy object
        strategy.behaviorInterface();
    }
}

// Step 4: Usage by the client.
public class Client {
    public static void main(String[] args) {
        // The client sets the strategy type at runtime
        Context context = new Context(new ConcreteStrategyA());
        context.someMethod(); // Output: Behavior for strategy A

        // The client can switch strategies
        context = new Context(new ConcreteStrategyB());
        context.someMethod(); // Output: Behavior for strategy B
    }
}



















                                                    TemplateMethod
abstract class AbstractClass {

    // The template method defines the skeleton of an algorithm.
    public final void templateMethod() {
        primitiveOperationA();
        primitiveOperationB();
    }

    // These operations have to be implemented in a subclass.
    abstract void primitiveOperationA();
    abstract void primitiveOperationB();
}

class ConcreteClass extends AbstractClass {

    // Implementing the primitive operations to carry out subclass-specific steps of the algorithm.
    void primitiveOperationA() {
        // Implementation of Primitive Operation A.
        System.out.println("Primitive Operation A performed by ConcreteClass.");
    }

    void primitiveOperationB() {
        // Implementation of Primitive Operation B.
        System.out.println("Primitive Operation B performed by ConcreteClass.");
    }
}

public class TemplateMethodPatternDemo {
    public static void main(String[] args) {
        AbstractClass abstractClass = new ConcreteClass();

        // The template method is called. This will execute the algorithm, with
        // the specific steps defined in the ConcreteClass.
        abstractClass.templateMethod();
    }
}










                                                    Visitor
// Visitor interface
interface Visitor {
    void visit(ConcreteElementA elementA);
    void visit(ConcreteElementB elementB);
}

// Concrete Visitors
class ConcreteVisitor1 implements Visitor {
    public void visit(ConcreteElementA elementA) {
        System.out.println("ConcreteVisitor1 visiting ConcreteElementA");
    }

    public void visit(ConcreteElementB elementB) {
        System.out.println("ConcreteVisitor1 visiting ConcreteElementB");
    }
}

class ConcreteVisitor2 implements Visitor {
    public void visit(ConcreteElementA elementA) {
        System.out.println("ConcreteVisitor2 visiting ConcreteElementA");
    }

    public void visit(ConcreteElementB elementB) {
        System.out.println("ConcreteVisitor2 visiting ConcreteElementB");
    }
}

// Element interface
interface Element {
    void accept(Visitor visitor);
}

// Concrete Elements
class ConcreteElementA implements Element {
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

class ConcreteElementB implements Element {
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

// Object Structure
class ObjectStructure {
    private List<Element> elements = new ArrayList<>();

    public void attach(Element element) {
        elements.add(element);
    }

    public void detach(Element element) {
        elements.remove(element);
    }

    public void accept(Visitor visitor) {
        for (Element element : elements) {
            element.accept(visitor);
        }
    }
}

// Client
public class Client {
    public static void main(String[] args) {
        ObjectStructure structure = new ObjectStructure();
        structure.attach(new ConcreteElementA());
        structure.attach(new ConcreteElementB());

        ConcreteVisitor1 visitor1 = new ConcreteVisitor1();
        ConcreteVisitor2 visitor2 = new ConcreteVisitor2();

        structure.accept(visitor1);
        structure.accept(visitor2);
    }
}









                                                                                                                        EZ (-_-)